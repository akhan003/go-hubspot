/*
Hubdb

HubDB is a relational data store that presents data as rows, columns, and cells in a table, much like a spreadsheet. HubDB tables can be added or modified [in the HubSpot CMS](https://knowledge.hubspot.com/cos-general/how-to-edit-hubdb-tables), but you can also use the API endpoints documented here. For more information on HubDB tables and using their data on a HubSpot site, see the [CMS developers site](https://designers.hubspot.com/docs/tools/hubdb). You can also see the [documentation for dynamic pages](https://designers.hubspot.com/docs/tutorials/how-to-build-dynamic-pages-with-hubdb) for more details about the `useForPages` field.  HubDB tables support `draft` and `published` versions. This allows you to update data in the table, either for testing or to allow for a manual approval process, without affecting any live pages using the existing data. Draft data can be reviewed, and published by a user working in HubSpot or published via the API. Draft data can also be discarded, allowing users to go back to the published version of the data without disrupting it. If a table is set to be `allowed for public access`, you can access the published version of the table and rows without any authentication by specifying the portal id via the query parameter `portalId`.

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hubdb

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// RowsBatchAPIService RowsBatchAPI service
type RowsBatchAPIService service

type ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest struct {
	ctx              context.Context
	ApiService       *RowsBatchAPIService
	tableIdOrName    string
	batchInputString *BatchInputString
}

// The JSON array of row ids
func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest) Execute() (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	return r.ApiService.PostCmsV3HubdbTablesTableIdOrNameRowsBatchReadExecute(r)
}

/*
PostCmsV3HubdbTablesTableIdOrNameRowsBatchRead Get a set of rows

Returns rows in the `published` version of the specified table, given a set of row ids.
**Note:** This endpoint can be accessed without any authentication if the table is set to be allowed for public access.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableIdOrName The ID or name of the table to query.
	@return ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest
*/
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsBatchRead(ctx context.Context, tableIdOrName string) ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest {
	return ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest{
		ApiService:    a,
		ctx:           ctx,
		tableIdOrName: tableIdOrName,
	}
}

// Execute executes the request
//
//	@return BatchResponseHubDbTableRowV3
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsBatchReadExecute(r ApiPostCmsV3HubdbTablesTableIdOrNameRowsBatchReadRequest) (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseHubDbTableRowV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RowsBatchAPIService.PostCmsV3HubdbTablesTableIdOrNameRowsBatchRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/hubdb/tables/{tableIdOrName}/rows/batch/read"
	localVarPath = strings.Replace(localVarPath, "{"+"tableIdOrName"+"}", url.PathEscape(parameterValueToString(r.tableIdOrName, "tableIdOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest struct {
	ctx              context.Context
	ApiService       *RowsBatchAPIService
	tableIdOrName    string
	batchInputString *BatchInputString
}

// The JSON array of row ids
func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest) Execute() (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	return r.ApiService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneExecute(r)
}

/*
PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchClone Clone rows in batch

Clones rows in the `draft` version of the specified table, given a set of row ids. Maximum of 100 row ids per call.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableIdOrName The ID or name of the table
	@return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest
*/
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchClone(ctx context.Context, tableIdOrName string) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest {
	return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest{
		ApiService:    a,
		ctx:           ctx,
		tableIdOrName: tableIdOrName,
	}
}

// Execute executes the request
//
//	@return BatchResponseHubDbTableRowV3
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneExecute(r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCloneRequest) (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseHubDbTableRowV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RowsBatchAPIService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/hubdb/tables/{tableIdOrName}/rows/draft/batch/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"tableIdOrName"+"}", url.PathEscape(parameterValueToString(r.tableIdOrName, "tableIdOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest struct {
	ctx                              context.Context
	ApiService                       *RowsBatchAPIService
	tableIdOrName                    string
	batchInputHubDbTableRowV3Request *BatchInputHubDbTableRowV3Request
}

// JSON array of row objects
func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest) BatchInputHubDbTableRowV3Request(batchInputHubDbTableRowV3Request BatchInputHubDbTableRowV3Request) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest {
	r.batchInputHubDbTableRowV3Request = &batchInputHubDbTableRowV3Request
	return r
}

func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest) Execute() (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	return r.ApiService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateExecute(r)
}

/*
PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreate Create rows in batch

Creates rows in the `draft` version of the specified table, given an array of row objects. Maximum of 100 row object per call. See the overview section for more details with an example.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableIdOrName The ID or name of the table
	@return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest
*/
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreate(ctx context.Context, tableIdOrName string) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest {
	return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest{
		ApiService:    a,
		ctx:           ctx,
		tableIdOrName: tableIdOrName,
	}
}

// Execute executes the request
//
//	@return BatchResponseHubDbTableRowV3
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateExecute(r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreateRequest) (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseHubDbTableRowV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RowsBatchAPIService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/hubdb/tables/{tableIdOrName}/rows/draft/batch/create"
	localVarPath = strings.Replace(localVarPath, "{"+"tableIdOrName"+"}", url.PathEscape(parameterValueToString(r.tableIdOrName, "tableIdOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputHubDbTableRowV3Request == nil {
		return localVarReturnValue, nil, reportError("batchInputHubDbTableRowV3Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputHubDbTableRowV3Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest struct {
	ctx              context.Context
	ApiService       *RowsBatchAPIService
	tableIdOrName    string
	batchInputString *BatchInputString
}

// JSON array of row ids.
func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeExecute(r)
}

/*
PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurge Permanently deletes rows

Permanently deletes rows from the `draft` version of the table, given a set of row ids. Maximum of 100 row ids per call.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableIdOrName The ID or name of the table
	@return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest
*/
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurge(ctx context.Context, tableIdOrName string) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest {
	return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest{
		ApiService:    a,
		ctx:           ctx,
		tableIdOrName: tableIdOrName,
	}
}

// Execute executes the request
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeExecute(r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurgeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RowsBatchAPIService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchPurge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/hubdb/tables/{tableIdOrName}/rows/draft/batch/purge"
	localVarPath = strings.Replace(localVarPath, "{"+"tableIdOrName"+"}", url.PathEscape(parameterValueToString(r.tableIdOrName, "tableIdOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest struct {
	ctx              context.Context
	ApiService       *RowsBatchAPIService
	tableIdOrName    string
	batchInputString *BatchInputString
}

// JSON array of row ids.
func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest) Execute() (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	return r.ApiService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadExecute(r)
}

/*
PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchRead Get a set of rows from draft table

Returns rows in the `draft` version of the specified table, given a set of row ids.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableIdOrName The ID or name of the table
	@return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest
*/
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchRead(ctx context.Context, tableIdOrName string) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest {
	return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest{
		ApiService:    a,
		ctx:           ctx,
		tableIdOrName: tableIdOrName,
	}
}

// Execute executes the request
//
//	@return BatchResponseHubDbTableRowV3
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadExecute(r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReadRequest) (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseHubDbTableRowV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RowsBatchAPIService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/hubdb/tables/{tableIdOrName}/rows/draft/batch/read"
	localVarPath = strings.Replace(localVarPath, "{"+"tableIdOrName"+"}", url.PathEscape(parameterValueToString(r.tableIdOrName, "tableIdOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest struct {
	ctx                                         context.Context
	ApiService                                  *RowsBatchAPIService
	tableIdOrName                               string
	batchInputHubDbTableRowV3BatchUpdateRequest *BatchInputHubDbTableRowV3BatchUpdateRequest
}

// JSON array of row objects.
func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest) BatchInputHubDbTableRowV3BatchUpdateRequest(batchInputHubDbTableRowV3BatchUpdateRequest BatchInputHubDbTableRowV3BatchUpdateRequest) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest {
	r.batchInputHubDbTableRowV3BatchUpdateRequest = &batchInputHubDbTableRowV3BatchUpdateRequest
	return r
}

func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest) Execute() (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	return r.ApiService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceExecute(r)
}

/*
PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplace Replace rows in batch in draft table

Replaces multiple rows as a batch in the `draft` version of the table, with a maximum of 100 rows per call. See the endpoint `PUT /tables/{tableIdOrName}/rows/{rowId}/draft` for details on updating a single row.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableIdOrName The ID or name of the table
	@return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest
*/
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplace(ctx context.Context, tableIdOrName string) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest {
	return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest{
		ApiService:    a,
		ctx:           ctx,
		tableIdOrName: tableIdOrName,
	}
}

// Execute executes the request
//
//	@return BatchResponseHubDbTableRowV3
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceExecute(r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplaceRequest) (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseHubDbTableRowV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RowsBatchAPIService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchReplace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/hubdb/tables/{tableIdOrName}/rows/draft/batch/replace"
	localVarPath = strings.Replace(localVarPath, "{"+"tableIdOrName"+"}", url.PathEscape(parameterValueToString(r.tableIdOrName, "tableIdOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputHubDbTableRowV3BatchUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("batchInputHubDbTableRowV3BatchUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputHubDbTableRowV3BatchUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest struct {
	ctx                                         context.Context
	ApiService                                  *RowsBatchAPIService
	tableIdOrName                               string
	batchInputHubDbTableRowV3BatchUpdateRequest *BatchInputHubDbTableRowV3BatchUpdateRequest
}

// JSON array of row objects.
func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest) BatchInputHubDbTableRowV3BatchUpdateRequest(batchInputHubDbTableRowV3BatchUpdateRequest BatchInputHubDbTableRowV3BatchUpdateRequest) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest {
	r.batchInputHubDbTableRowV3BatchUpdateRequest = &batchInputHubDbTableRowV3BatchUpdateRequest
	return r
}

func (r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest) Execute() (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	return r.ApiService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateExecute(r)
}

/*
PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdate Update rows in batch in draft table

Updates multiple rows as a batch in the `draft` version of the table, with a maximum of 100 rows per call. See the endpoint `PATCH /tables/{tableIdOrName}/rows/{rowId}/draft` for details on updating a single row.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableIdOrName The ID or name of the table
	@return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest
*/
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdate(ctx context.Context, tableIdOrName string) ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest {
	return ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest{
		ApiService:    a,
		ctx:           ctx,
		tableIdOrName: tableIdOrName,
	}
}

// Execute executes the request
//
//	@return BatchResponseHubDbTableRowV3
func (a *RowsBatchAPIService) PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateExecute(r ApiPostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdateRequest) (*BatchResponseHubDbTableRowV3, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseHubDbTableRowV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RowsBatchAPIService.PostCmsV3HubdbTablesTableIdOrNameRowsDraftBatchUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/hubdb/tables/{tableIdOrName}/rows/draft/batch/update"
	localVarPath = strings.Replace(localVarPath, "{"+"tableIdOrName"+"}", url.PathEscape(parameterValueToString(r.tableIdOrName, "tableIdOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputHubDbTableRowV3BatchUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("batchInputHubDbTableRowV3BatchUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputHubDbTableRowV3BatchUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
